import { GoogleGenAI } from "@google/genai";

const getAiClient = () => {
  const apiKey = process.env.API_KEY;
  if (!apiKey) {
    throw new Error("API Key is missing. Please check your environment variables.");
  }
  return new GoogleGenAI({ apiKey });
};

/**
 * Sends an image and a prompt to Gemini to generate an edited version.
 * Specifically tailored for changing clothes.
 */
export const generateOutfitChange = async (
  imageBase64: string,
  prompt: string,
  allowNSFW: boolean = false
): Promise<string> => {
  const ai = getAiClient();
  
  // Extract mime type from base64 string if present
  let mimeType = 'image/jpeg';
  const mimeMatch = imageBase64.match(/^data:(image\/[a-zA-Z+]+);base64,/);
  if (mimeMatch && mimeMatch[1]) {
    mimeType = mimeMatch[1];
  }

  // Clean base64 string if it contains the data URL prefix
  const cleanBase64 = imageBase64.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, "");

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
          {
            inlineData: {
              data: cleanBase64,
              mimeType: mimeType, 
            },
          },
          {
            text: `Edit this image to completely change the person's clothing. 
            The goal is a realistic virtual try-on.
            Maintain the person's exact face, identity, body shape, pose, and the original background.
            Only modify the clothing area.
            
            New outfit instructions: ${prompt}`,
          },
        ],
      },
      config: {
        safetySettings: allowNSFW ? [
          {
            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            threshold: 'BLOCK_NONE',
          },
          {
            category: 'HARM_CATEGORY_HARASSMENT',
            threshold: 'BLOCK_NONE',
          },
          {
            category: 'HARM_CATEGORY_HATE_SPEECH',
            threshold: 'BLOCK_NONE',
          },
          {
            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
            threshold: 'BLOCK_NONE',
          }
        ] : undefined,
      }
    });

    // Robust response handling
    const candidate = response.candidates?.[0];

    if (!candidate) {
      throw new Error("The model failed to generate a response. Please try again.");
    }

    // Check for safety blocking or other finish reasons that prevent content generation
    if (candidate.finishReason === 'SAFETY' || candidate.finishReason === 'IMAGE_SAFETY') {
      throw new Error("The request was blocked by safety filters. You may try enabling 'Sensitive Content' or using a less explicit prompt.");
    }
    
    // Handle IMAGE_OTHER or OTHER specifically which often comes with no content
    if (candidate.finishReason === 'OTHER' || candidate.finishReason === 'IMAGE_OTHER') {
        throw new Error("The model was unable to process this image. This can happen if the image is too complex, unclear, or violates specific generation policies. Please try a different photo.");
    }

    if (!candidate.content || !candidate.content.parts) {
      throw new Error(`Model finished with reason: ${candidate.finishReason || 'Unknown'}, but returned no content.`);
    }

    const parts = candidate.content.parts;
    for (const part of parts) {
      if (part.inlineData && part.inlineData.data) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }
    
    // If we have parts but no image (e.g. only text saying "I cannot do that")
    const textPart = parts.find(p => p.text);
    if (textPart && textPart.text) {
      throw new Error(`Model refused to generate image: ${textPart.text}`);
    }

    throw new Error("No image generated by the model.");

  } catch (error) {
    console.error("Gemini API Error:", error);
    throw error;
  }
};
